## 16진수(Hexadecimal)
- 10진수를 16진수로 바꾸어보기
  - 10은 a, 11은 b, …, 15는 f를 대입
  - 0x를 붙혀 뒤에 오는 문자들이 16진수임을 알려줌
- 2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용

## 메모리 주소
- C에서는 변수의 메모리상 주소를 받기 위해 '&'이라는 연산자를 사용
```C
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```
- 변수의 메모리 주소에 있는 실제 값을 얻기 위해 '*'를 사용
```C
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

## 포인터
- '*'를 사용해 포인터 역할을 하는 변수 선언
```C
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n; //*p라는 포인터 변수에 &n(변수 n의 주소)를 저장
   printf("%p\n", p); //포인터 p의 값 : 변수 n의 주소를 출력
   printf("%i\n", *p); //포인터 p가 가리키는 변수의 값 : 변수 n의 값을 출력
}
```
## 문자열
- string 자료형 == char *string
```C
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = "EMMA";
    printf("%s\n", s);
}
```
```C
#include <stdio.h>

int main(void)
{
    char *s = "EMMA"; //s라는 변수는 문자에 대한 포인터
    printf("%s\n", s);
}
```
- 위의 두 코드는 동일하게 동작

## 문자열의 비교
- 문자열이 저장된 변수를 바로 비교하게 되면 그 변수가 저장된 주소가 다르기 때문에 다르다는 결과가 나옴
- 정확한 비교를 위해서 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나하나씩 비교

## 문자열 복사
- 메모리의 주소를 복사하는게 아닌 실제 메모리상의 내용을 복사하려면 메모리 할당 함수(malloc)를 이용
- malloc : 정해진 크기 만큼 메모리를 할당하는 함수 (즉, 문자열의 길이에 널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당)
- malloc 함수로 문자열 길이+1 만큼 메모리를 할당하고 루프를 돌면서 문자열 배열에 있는 문자 하나 하나를 t배열에 복사해주면 된다.

## 메모리 할당과 해제
- 메모리를 할당한 후 메모리를 해제해줘야 메모리에 저장한 값을 쓰레기 값으로 남겨서 메모리 용량의 낭비(메모리 누수)가 발생하지 않음
- free 함수 이용 ex) free(x)
- valgrind라는 프로그램을 사용하면 작성한 코드에서 메모리와 관련된 문제가 있는지를 쉽게 확인 가능
  - ex) help50 valgrind ./filename
  
