## 알고리즘 표기법
- Big O : 알고리즘의 실행 시간의 상한
  - O(n^2): 선택 정렬, 버블 정렬
  - O(n log n)
  - O(n) : 선형 검색
  - O(log n) : 이진 검색
  - O(1)
- Big Ω : 알고리즘 실행 시간의 하한
  - Ω(n^2) : 선택 정렬, 버블 정렬
  - Ω(n log n)
  - Ω(n) : 버블 정렬(조건부)
  - Ω(log n)
  - Ω(1) : 선형 검색, 이진 검색
- ex) 선형 검색에서는 n개의 항목이 있을때 최대 n번의 검색을 해야 하므로 상한이 O(n)이 되지만 운이 좋다면 한 번만에 검색을 끝낼수도 있으므로 하한은 Ω(1)

## 선형 검색
- 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색
- 정확하지만 아주 효육적이지 못한 방법
- 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용

## 이진 검색
- 만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복하면 된다.

## 구조체
- 특정 이름을 찾아 해당하는 전화번호를 출력하는 프로그램
- 이름과 전화번호를 각각 다른 배열에 정의하면 서로 같은 인덱스를 가져야 한다는 한계가 존재
- person이라는 이름의 구조체를 자료형으로 정의하고 person자료형의 배열을 선언하면 그 안에 포함된 속성값은 '.'으로 연결해서 접근 가능
```C
#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";

    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

## 버블 정렬
- 정렬 알고리즘
- 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
- 단 두개의 요소만 정렬해주는 좁은 범위의 정렬에 집중
- 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있음
- 소요 시간의 상한은 O(n^2)이 되고, 하한도 마찬가지로 Ω(n^2)
- 정렬이 모두 되어 있다면 하한은 Ω(n), 상황에 따라서는 선택 정렬보다 더 빠른 방법

## 선택 정렬
- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬
- 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가
- 소요 시간의 상한은 O(n^2)이 되고, 하한도 마찬가지로 Ω(n^2)

## 병합 정렬
- 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식
- 재귀적으로 구현됨
- 소요 시간의 상한은 O(n log n)이 되고, 하한도 마찬가지로 Ω(n log n)
- 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸림
- 숫자들이 이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문

## 재귀
- 함수가 본인 스스로를 호출해서 사용
- 중첩루프를 사용하지 않고도 하나의 함수로 동일한 작업을 수행할 수 있음
