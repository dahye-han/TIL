## 배열의 크기 조정하기
- 일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면 안전하게 새로운 공간에 큰 크기의 메모리를 다시 할당하고 기존 배열의 값들을 하나씩 옮겨야 함
- O(n) : 배열의 크기 n만큼의 실행 시간이 소요
- realloc 함수 :  ex) int *tmp = realloc(list, 4 * sizeof(int));

## 연결 리스트 
  ### 도입
  - 데이터 구조 : 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체
  - 연결 리스트 : 메모리안에 여러 군데로 값이 나눠져 있을때 바로 다음 값의 메모리 주소만 기억하면 배열과 같이 값을 연이어서 읽을 수 있음
    - 각 인덱스의 메모리 주소에서 자신의 값과 함께 바로 다음 ㄱ밧의 주소(포인터)를 저장
  ```C
  typdef struct node
  {
    int number;
    struct node *next;
  }
  node;
  ```
  
  ### 코드
  ```C
  #include <stdio.h>
  #include <stdlib.h>

  //연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
  typedef struct node
  {
      //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
      int number; 

      //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
      struct node *next;
  }
  node;

  int main(void)
  {
      // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
      // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
      node *list = NULL;

      // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
      node *n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }

      // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
      // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
      // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
      n->number = 1;

      // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
      n->next = NULL;

      // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
      list = n;

      // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }

      // n의 number와 next의 값을 각각 저장합니다.
      n->number = 2;
      n->next = NULL;

      // list가 가리키는 것은 첫 번째 node입니다. 
      //이 node의 다음 node를 n 포인터로 지정합니다.
      list->next = n;

      // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
      n = malloc(sizeof(node));
      if (n == NULL)
      {
          return 1;
      }

      n->number = 3;
      n->next = NULL;

      // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
      // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
      // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
      list->next->next = n;

      // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
      // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
      for (node *tmp = list; tmp != NULL; tmp = tmp->next)
      {
          printf("%i\n", tmp->number);
      }

      // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
      while (list != NULL)
      {
          node *tmp = list->next;
          free(list);
          list = tmp;
      }
  }
  ```
  ### 시연
  - 연결 리스트 : 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 되지만, 임의 접근이 불가능
  - 연결 리스트에 값을 추가하거나 검색하려면 해당하는 위치까지 연결 리스트의 각 nod들을 따라 이동해야함
  - 연결 리스트의 실행시간은 O(n), 배열(정렬되어 있는 경우)은 이진 검색을 이용하면 실행시간은 O(log n)
  
  ### 트리
  - 연결리스트에서 각 노드들이 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성되어 있음
  - 각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가짐
  
  ### 해시 테이블
  - 연결리스트의 배열
  - 해시 함수가 이상적이라면, 각 배열에는 단 하나의 값들만 담겨서, 검색 시간은 O(1)
  - 최악의 상황에서는 단 하나의 배열에 모든 값들이 담겨서 O(n)이 될수도 있음
  - 일반적으로는 최대한 많은 배열을 만드는 해시 함수를 사용하기에 거의 O(n)
  
  ### 트라이
  - 기본적으로 '트리' 형태의 자료 구조 이나, 각 노드가 '배열'로 이루어져있음
  - 일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않아서 O(1)이나 마찬가지
  - 해시 테이블에 비해 실행시간은 단축되지만, 메모리 차지가 큼
  
## 스택, 큐, 딕셔너리
  ### 스택
  - 값이 아래로 쌓이는 구조
  - '선입선출', 'FIFO'
  - 가장 먼저 들어온 값이 가장 먼저 나감
  - 배열이나 연결 리스트를 통해 구현 가능
  
  ### 큐
  - 값이 위로 쌓이는 구조
  - '후입선출', 'LIFO'
  - 가장 나중에 들어온 값이 가장 먼저 나감
  - 배열이나 연결 리스트를 통해 구현 가능
  
  ### 딕셔너리
  - '키'와 '값'이라는 요소로 이루어져 있음
  - '키'에 해당하는 '값'을 저장하고 읽어옴
  - 일반적인 의미에서 '해시 테이블'과 동일한 개념이라고 볼 수도 있음(키를 어떻게 정의하는냐가 중요)
