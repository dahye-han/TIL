프로그램의 코드는 순차적으로 진행(동기적)
어떤 함수의 결과가 다른 함수에 영향을 받는다면, 그 함수는 다른 함수가 끝나고 값을 산출할 때까지 기다려야 함
위의 과정이 끝날때까지 유저의 입장에서 보자면, 전체 프로그램이 모두 멈춘 것처럼 보임
blocking : 사용자의 입력을 처리하느라 웹 앱이 프로세서 대한 제어권을 브라우저에게 반환하지 않는 현상

- 비동기
    - 다름 코어 프로세서에 다른 작업들을 움직이게 하고 작업이 완료되면 알려줄 수 있을 때,
      무언가를 기다리기 보다 그 동안 다른 작업을 수행할 수 있음(비동기)

- Threads : 기본적으로 프로그램이 작업을 완료하는데 사용할 수 있는 단일 프로세스
    - 각 스레드는 한 번에 하나의 작업만 수행(Task A -> Task B -> Task C)
    - 다음 작업을 실행하려면 앞의 작업이 완료되어야함
    - 많은 컴포터들이 현재 여러 개의 CPU 코어를 가지고 있기 때문에 한번에 여러가지 일을 수행할 수 있음
    - Multiple thread를 지원하는 프로그래밍 언어는 멀티코어 컴퓨터의 CPU를 사용하여 여러 작업을 동시에 처리 할 수 있음

- 자바 스크립트는 전통적으로 싱글 thread
    - 이런 문제를 해결하기 위해 worker라고 불리는 별도의 스레드 도입
    - 시간이 오래 걸리는 처리는 worker를 사용해 처리하면 blocking발생을 막을 수 있음
    Main thread : Task A -> Task C
    Worker thread : Expensive task B
    => 첫 번쨰 작업이 두 번째 작업을 차단하지 않음
    => Worker는 DOM에 접근할 수 없어서 UI를 업데이트 할 수 없다
    => 함수가 일의 처리를 위해 이전의 여러 프로세스의 결과를 return 받아야 할 경우
    이러한 문제를 해결하기 위해 브라우저를 통해 틀정 작업을 비동기적으로 실행 할 수 있음
    => Promises를 사용 => A가 서버에서 이미지를 가져오는 동안 B를 기다리게 할 수 있음

- Async callbacks
    - 백그라운드에서 코드 실행을 시작할 함수를 호출할 떄 인수로 지정된 함수
    - 백그라운드 코드 실행이 끝나면 callback 함수를 호출하여 작업이 완료됐음을 알리거나, 다음 작업을 실행하게 할 수 있음
    - 지금은 약간 구식
    - 함수가 실행되는 순서, 함수간에 어떤 데이터가 전달되는지를 제어할 수 있음
    - 상황에 따라 다른 함수로 데이터를 전달 할 수 있음
    - 모든 callback이 비동기인 것은 아님

- Promises
    - callback 함수를 장착하고 있는 returned된 오브젝트
    - fetch()는 XMLHttpRequest 보다 좀 더 현대적인 버전
    - fetch()는 단일 매개변수만 전달 받음
    - promise => 비동기 작업이 성공했는지 혹은 실패했는지를 나타내는 하나의 오브젝트
    - .then() => 이전 작업이 성공했을 때 수행할 작업을 나타내는 callback 함수
    - .catch() => .then()이 하나라도 실패하면 동작
        - error 오브젝트는 catch() 블럭 안에서 사용할 수 있으면, 발생한 오류를 보고하는 용도로 사용할 수 있음
        - try ~ catch 는 async/await에서는 동작하지만, promise와 함께 동작할 수 없음
    - 어떤 작업의 중간상태를 나타내는 오브젝트 
    - 작업이 완료되어 결과를 반환해주는 정확한 시간을 보장해주지는 않지만, 
      사용할 수 있는 결과를 반환했을때 프로그래머의 의도대로 다음 코드를 진행 시키거나, 에러가 발생했을 때 그 에러 깔끔하게 처리
    
    - promise가 생성되면 그 상태는 성공도 실패도 아닌 pending 상태
    - promise 결과가 반환되면 결과에 상관 없이 resolved 상태
        - 성공적으로 처리된 promise는 fulfilled 상태
            - .then() 블럭에서 사용할 수 있는 값을 반환
            - .then() 블럭 내부의 executor 함수에 Promise 에서 반환된 값이 파라미터로 전달
        - 실패한 promise는 rejected 상태
            - .catch()에서 상세한 에러 메시지를 확인할 수 있음
    
    - promise.all() 
        - 모든 promise가 fulfilled 일 경우 코드를 실행
    
    - .finally()
        - promise 체이닝 끝에 배치하여 코드 반복을 줄이고 좀 더 우아하게 일을 처리할 수 있음
    
    myPromise
    .then(response => {
        doSomething(response);
    })
    .catch(e => {
        returnError(e);
    })
    .finally(()=> {
        runFinalCode();
    });

- setTimeout()
    - 특정 시간이 경과한 뒤에 특정 코드블록을 한번 실행
    - 일정 시간이 지난 후 코드를 한 번 실행해야 할 떄 완벽하게 작동
    - 첫번째 매개 변수(함수)가 타임아웃 후에 한번 실행

- setInterval()
    - 각각의 호출 간에 일정한 시간 간격으로 특정 코드블록을 반복적으로 실행
    - 애니메이션의 경우와 같이 코드를 반복해서 실행해야 하는 경우에 사용
    - 두번째 매개변수에 주어진 시간까지 반복적으로 실행
    ex) 초당 한번 업데이트 되는 디지털 시계와 같은 효과


- requestAnimationFrame()
    - setInterval()의 최신 버전
        - setInterval()의 문제점을 개선
            - 장치에 최적화 된 프레임 속도로 실행되지 않는 문제
            - 프레임을 빠뜨리는 문제
            - 탭이 활성탭이 아니거나 애니메이션 페이지를 벗어난 경우에도 계속 실행되는 문제 
    - 코드가 실행되는 환경에 관계없이 적절한 프레임 속도로 애니메이션을 실행시키면서,
      브라우저가 다음 화면을 보여주기 전에 특정 코드블록을 실행
    - 화면을 다시 표시하기 전에 호출 할 콜백을 인수로 사용
    - 시간 간격을 지정하지 않음
    - 현재 상황에서 최대한 빠르고 원할하게 실행
    - Internet Explorer 10 이상에서 사용
    

- clearTimeout(setTimeout()의 식별자)
    - setTimeout()이 실행되고 특정시간이 경과하기 전에 clearTimeout()을 호출하여 타임아웃을 취소할 수 있음

- async / await
    - async function()은 await 키워드가 비동기 코드를 호출할 수 있게 해주는 함수
    - async 를 함수와 같이 사용하면 결과를 직접 반환하는게 아니라 Promise를 반환
    - await
        - 어떠한 Promise 기반 함수 앞에 놓을 수 있음
        - 우리의 코드의 Promise가 fulfill 될 떄까지 잠시 중단하고, 결과를 반환
        - 실행을 기다리는 다른 코드들을 중지시키지 않고 그대로 실행
    - 비동기 코드를 실행할 블럭을 정의하려면 비동기 함수를 생성해야 함
        - await는 async function 안에서만 쓸 수 있음
        
