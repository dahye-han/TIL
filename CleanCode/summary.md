## 코드 : 요구사항을 표현하는 언어

## 깨끗한 코드
- 세세한 사항까지 꼼꼼하게 처리하는 코드(오류 처리, 메모리 누수 처리, 경쟁 상태 처리, 일관성 없는 명명법 처리)
- 단순하고 직접적이어서 반드시 필요한 내용만을 담아내는 코드
- 작성자가 아닌 사람도 읽기 쉽고 고치기 쉬운 코드
- 이미 모든 사항을 고려해서 주의 깊게 작성한 코드
- 중복을 피하고, 한기능만 수행하며, 제대로 표현하고, 작게 추상화한 코드
- 읽으면서 집작한 대로 돌아가는 코드

## 의미 있는 이름
- 따로 주석이 필요없이 변수의 존재 이유, 수행 기능, 사용 방법을 알 수 있음
- 코드의 함축성이 중요
 ```
 public List<int[]> getThem(){
   List<int[]> list1 = new ArrayList<int[]>();
   for(int[] x: theList)
     if (x[0] == 4)
       list1.add(x);
   return list1;
 }

 public List<int[]> getFlaggedcells() {
   List<int[]> flaggedCells = new ArrayList<int[]>();
   for (int[] cell : gameBoard)
     if(cell[STATUS_VALUE] == FLAGGED)
       flaggedCells.add(cell);
   return flaggedCells;
 }

 //코드의 단순성을 변하지 않았지만, 코드는 더욱 명확해짐
 ```
- 널리 쓰이는 의미가 있는 단어(hp, aix, sco 등)를 다른 의미로 사용하는걸 지양
- 의미 없이 연속된 숫자(a1, a2...)를 덧붙이거나 불용어(Info,Data...)를 추가하는 방식은 지양
- 발음하기 쉬운 이름을 사용하는걸 지향
- 검색하기 쉬운 이름을 사용하는걸 지향
  - 이름을 의미 있게 지으면 함수가 길어지지만 찾기 쉬워짐
- 클래스 이름, 객체 이름 : 명사나 명사구가 적합(Customer, WikiPage, Account, AddressParser)
- 매서드 이름 : 동사나 동사구가 적합(postPayment, deletePage,save)
- 기발한 이름보다 명료한 이름을 선택
- 한 개념에 한 단어를 사용하고, 기존의 메서드와 맥락이 다르면 다른 단어를 사용
  - add가 기존 값 두개를 더하거나 이어서 새로운 값을 만드는 것일때, 새로 작성하는 메서드는 집합에 값 하나를 추가한다면 메서드의 이름은 insert나 append가 적당
- 프로그래머에게 익숙한 기술 개념에는 기술 개념을 사용, 적절한 용어가 없다면 문제 영역에서 이름을 가져옴

## 함수
- 작게 만들어야 함
- 함수는 한가지만을 잘 해야함
- 함수 당 추상화 수준은 하나여야 함
- switch문
  - 본질적으로 switch문은 N가지를 처리하여 하기에 한 가지 작업만하도록 작게 만들기가 어려움
  - 다형성을 이용하여 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지않는 방법이 있음
  ```
  public Money calculatePay(Employee e)
  throws InvalidEmployeeType {
    switch (e.type) {
      case COMMISSIONED:
        retuen calculateCommissionedPay(e);
      case HOURLY:
        return calculateHourlyPay(e);
      case SALARIED:
        return calculateSalariedPay(e);
      default:
        throws new InvalidEmployeeType(e.type);
    }
  }
  
  //아래의 내용으로 개선
  
  public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money caculatePay();
    public abstract void deliverPay(MoneyPay);
  }
  public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
      switch (r.type) {
        case COMMISSIONED:
          return new CommissionedEmployee(r);
        case HOURLY:
          return new HourlyEmployee(r);
        case SALARIED:
          return new SalariedEmployee(r);
        default:
          throw new InvalidEmployeeType(r.type);
      }
    }
  }
  ```
- 서술적인 이름을 사용
 - 길고 서술적인 이름이 짧고 어려운 이름보다 좋음
 - 모듈 내에서 함수 이름은 같은 문고, 명사, 동사를 사용
- 함수 인수 
  - 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우
  - 플래그 인수 : 함수가 한꺼번에 여러 가지를 처리
    - ex) render(true) => render(boolean isSuite) => renderForSuite() / renderForSingleTest()
  - 이항 함수 : 이항 함수가 적절한 경우도 있음 ex) Pont p = new Point(0,0) => 인수 2개가 하나의 값을 표현
    - 무조건 나쁘지는 않지만 그만큼 위험이 따름
- 부수 효과를 일으키지 않게 작성
- 명령과 조회를 분리
  - 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야함
- 오류 코드보다 예외를 사용
  ```
  public void delete(Page page) {
    try {
      deletePageAndAllReferences (page);
    } catch {
      logError(e);
    }
  }
  
  private void deletePageAndAllReferences(Page page) throws Exception {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deletekey(page.name.makeKey());
  }
  
  private void logError(Exception e) {
    logger.log(e.getMessage());
  }
  ```

## 주석
- 주석이 필요한 상황에 처하면 상황을 역전해 코드로 의도를 표현할 방법을 없을지 고민, 코드로 의도를 표현하는게 가장 좋음
- 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁨
- 주석보다 코드로 의도를 표현
- 좋은 주석
  - 법적인 주석 : 법적인 이유로 특정 주석을 넣으라고 명시한 경우 ( 저작권 정보, 소유권 정보 )
  - 정보를 제공하는 주석 : 정규표현식이 어떤것을 뜻하는지 표시 => 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 주석이 필요없어짐
  - 의도를 설명하는 주석 : 결정에 깔린 의도까지 설명
  - 의미를 명료하게 밝히는 주석 : 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용
     - 주석이 올바른지 검증이 쉽지 않음
  - 결과를 경고하는 주석 : 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용
  - TODO 주석 : ex) // TODO-MdM 현재 필요하지 않다.
  - 중요성을 강조하는 주석
  - 공개 API에서 Javadocs
- 나쁜 주석
  - 주절거리는 주석 
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 이력을 기록하는 주석 : 현재는 소스 코드 관리 시스템을 이용
  - 있으나 마나 한 주석 
  - 무서운 잡음 
  - 함수나 변수로 표현할 수 있다면 주석을 달지 마라
  - 위치를 표시하는 주석
  - 닫는 괄호에 다는 주석 : 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화된 함수에는 잡음일 뿐
  - 공로를 돌리거나 저자를 표시하는 주석 : ex) /* 릭이 추가함 */
  - 주석으로 처리한 코드
  - HTML 주석
  - 전역 정보
  - 너무 많은 정보
  - 모호한 관계 : 주석과 주석이 설명하는 코드 사이의 관계가 모호한 경우
  - 함수 헤더 : 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 좋음
  - 비공개 코드에서 Javadocs
  
## 형식 맞추기
  - 형식을 맞추는 목적 : 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미침
  - 적절한 행 길이를 유지하라
    - 신문 기사처럼 작성하라
      - 이름은 간단하면서도 설명이 가능하게 지음 : 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 지음
      - 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명
      - 아래로 내려갈수록 의도를 세세하게 묘사
      - 마지막에는 가장 저차원 함수와 세부 내역이 나옴
    - 개념은 빈 행으로 분리하라
      - 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현함
      - 생각 사이는 빈 행을 넣어 분리 : 빈 행은 새로운 개념을 시작한다는 시각적 단서
      - 세로 밀집도 : 서로 밀접한 코드 행은 세로로 가까이 놓아 연관성이 높음을 표시
        - 변수 선언 : 변수는 사용하는 위치에 최대한 가까이 선언
        - 인스턴스 변수 : 클래스 맨 처음에 선언한다
        - 종속 함수 
          - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치
          - 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치
        - 개념의 유사성 : 비슷한 동작을 수행하는 함수들은 종속적인 관계가 없더라도 가가이 배치
      - 세로 순서 : 중요한 개념을 가장 먼저 표현하면서 세세한 사항은 가장 마지막에 표현
        - 가로 형식 맞추기 : 100자나 120자 정도가 적당
      - 들여쓰기 : 범위로 이뤄진 계층을 표현하기 위해 사용
        - 클래스 정의처럼 파일 수준인 문장은 들여쓰지 않음
        - 클래스 내 메서드는 클래스보다 한 수준 들여씀
        - 메서드 코드는 메서드 선언보다 한 수준 들여씀
        - 블록 코드는 블록을 포함하는 코드보다 한 수준 들여씀
  
## 객체와 자료 구조
  - 자료 추상화
    - 구현을 감추기 위해서는 추상화가 필요함
    - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스
  - 자료/객체 비대칭
    - 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개
    - 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음
    - 절차적인 코드는 자료 구조를 추가하기 어려움 => 모든 함수를 고쳐야함
    - 객체 지향 코드는 새로운 함수를 추가하기 어려움 => 모든 클래스를 고쳐야함
  - 디미터 법칙
    - 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안됨
    - 객체라면 내부 구조를 숨겨야 함
    - 자료 구조라면 당연히 내부 구조를 노출해야함
  - 자료 전달 객체
    - 자료 구조체의 전형적인 형태는 공개 변수만 있고 ㅎ마수가 없는 클래스
    - 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라고 함
      - DTO는 데이터베이스에서 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체
    - 좀 더 일반적인 형태는 bean
      - 비공개(private) 변수를 조회/설정 함수로 조작
    - 활성 레코드
      - DTO의 특수한 형태
      - 데이터 베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과
      - 자료 구조로 취급해서 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성

## 오류 처리
- 오류 코드보다 예외를 사용하라
- Try-Catch-Finally 문부터 작성하라
  - 어떤 면에서는 try블록은 트랜잭션과 비슷
  - 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장
- 미확인(unchecked) 예외를 사용하라
- 예외에 의미를 제공하라
  - 예외를 던질 때는 전후 상황을 충분히 덧붙임
  - 오류가 발생한 원인과 위치를 찾기가 쉬워짐
  - 오류메시지에 정보(실패한 연산 이름,실패 유형)를 담아 예외와 함께 던짐
- 호출자를 고려해 예외 클래스를 정의
  - 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법
  - 오류가 발생한 위치, 유형으로 분류가 가능(디바이스 실패, 네트워크 실패, 프로그래밍 오류 등)
  - 외부 API를 사용할 때는 감싸기 기법이 최선 : 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어듬
  - 감싸기 기법을 사용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않음
- null을 반환하지 마라
  - 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환
  - 사용하려는 외부 API가 null을 반환한다면 감사기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환
- null을 전달하지 마라
  - 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피함
  - 인수로 null을 전달해 NullPointerException이 발생
    - 새로운 예외 유형을 만들어 던짐 : if(p1 == null || p2 == null)
    - InvalidArgumentException 예외 처리 : assert문 사용
    - 애초에 null을 인수로 넘기지 못하도록 금지하는 정책을 만듬
    
## 경계
- 외부 코드를 우리 코드에 깔끔하게 통합할 때, 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교
- 외부 코드 사용
  - 경계 인터페이스를 이용할 대는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의
- 경계 살피고 익히기
  - 학습테스트
    - 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성
    - 통제된 환경에서 API를 제대로 이해하는지를 확인
    - 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인
- log4j 익히기
  ```
  public class LogTest { 
    private Logger logger;
    
    @Before
    public void initialize() {
      logger = Logger.getLogger("logger");
      logger.removeAllAppenders();
      Logger.getRootLogger().removeAllAppenders();
    }
    
    @Test
    public void basicLogger() {
      BasicConfigurator.configure();
      logger.info("basicLogger");
    }
    
    @Test
    public void addAppenderWithStream() {
      logger.addAppender(new ConsoleAppender(
        new PatternLayout("%p %t %m%n"),
        ConsoleAppender.SYSTEM_OUT));
        logger.info("addAppenderWithStream");
    }
  }
  ```

## 단위 테스트
- TDD(Test Driven Development) 법칙 세 가지
  - 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  - 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
  - 깨끗한 테스트 코드 유지하기
    - 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
    - 테스트 케이스가 없다면 모든 변경이 잠정적인 버그
  - 깨끗한 테스트 코드
    - 테스트 코드에서 가독성을 높이기 위해 명료성, 단순성, 풍부한 표현력이 필요
    - BUILD-OPERATE-CHECK 패턴
      - BUILD : 테스트 자료를 만든다.
      - OPERATE : 테스트 자료를 조작한다.
      - CHECK : 조작한 결과가 올바른지 확인한다.
    - 도메인에 특화된 테스트 언어 (DSL) : 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어
    - 이중 표준 : 실제환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식으로 메모리나 CPU 효율과 관련 잇는 경우 사용
    - 테스트 당 assert 하나
      - JUnit으로 테스트 코드를 짤 때는 함수마다 assert 문을 단 하나만 사용해야 한다는 주장
      - 테스트 함수마다 한 개념만 테스트하라
    - F.I.R.S.T
      - Fast : 테스트는 빨라야 한다.
      - Independent : 각 테스트는 서로 의존하면 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.
      - Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다.
      - Self-Validating : 테스트는 bool 값으로 결과를 내야 한다.(성공 아니면 실패)
      - Timely : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
      
## 클래스
- 클래스 체계 : 변수( 정적 공개 상수 - 정적 비공개 변수 - 비공개 인스턴스 변수 ) - 공개 함수 - 비공개 함수
- 클래스는 작아야 함
  - 클래스가 맡은 책임 기준
  - 클래스 이름은 해당 클래스 책임을 기술
  - 클래스 설명은 and, if, or, but을 사용하지 않고서 25단어 내외로 가능해야함
    - 단일 책임 원칙 : 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙
      - 소프트웨어를 돌아가게 만드는 활동과 소트프웨어를 깨끗하게 만드는 활동은 완전히 별개
      - 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직
      - 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행
    - 응집도(Cohesion) 
      - 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높음
      - 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미
      - 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두 세 개로 쪼개줌

## 시스템
- 시스템 제작과 시스템 사용을 분리
  - Main 분리
    - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정
    - main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘김
    - 애플리케이션은 그저 객체를 사용할 뿐, main이나 객체가 생성되는 과정을 전혀 모름
  - 의존성 주입 : 사용과 제작을 분리하는 강력한 매커니즘 중 하나
    - 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘김
    - 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 됨
    - 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않고, 이런 책임을 다른 전담 매커니즘에 넘겨서 제어를 역전
    - DI 컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정
    - 실제로 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시
- 확장
    //p.202-p.214 추후 정리

## 창발성
- 창발적 설계로 깔끔한 코드를 구현
  - 모든 테스트를 실행
    - 테스트가 가능한 시스템 : 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템
    - 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아짐
    - 낮은 결합도와 높은 응집력을 가짐
    - 리팩터링
      - 코드를 점진적으로 리팩터링 해나감
      - 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택
  - 중복을 없앰
  - 프로그래머 의도를 표현
    - 좋은 이름을 선택 : 이름과 기능이 같아야 함
    - 함수와 클래스 크기를 가능한 줄임
    - 표준 명칭을 사용
    - 단위 테스트 케이스를 꼼꼼히 작성
  - 클래스와 메서드 수를 최소로 줄임
    - 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지
  

## 동시성
- 동시성이 필요한 이유?
  - 동시성은 결합을 업애는 전략 : 무엇과 언제를 분리하는 전략
  - 동시성은 다소 부하를 유발 : 성능 측면에서 부하가 걸리며, 코드도 더 짜야함
  - 동시성은 복잠 : 간단한 문제라도 동시성은 복잡
  - 일반적으로 동시성 버그는 재현하기 어려움 : 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉬움
  - 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 함
- 동시성 방어 원칙 : 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술
  - 단일 책임 원칙
    - 주어진 메서드/클래스/컴포넌트를 2변경할 이유가 하나여야 한다는 원칙
    - 동시성을 구현할 때 고려할 점
      - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있음
      - 동시성 코드에는 독자적인 어려운 난관이 있음
      - 잘못 구현한 동시성 코드는 별의별 방식으로 실패함(동시성 하나만으로도 충분히 어려움)
  - 따름 정리 
    - 자료 범위를 제한
      - 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하도록 권장
      - 자료를 캡슐화하고, 공유 자료를 최대한 줄임
    - 자료 사본을 사용
      - 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋음
        - 객체를 복사해 읽기 전용으로 사용하는 방법
        - 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법
    - 스레드는 가능한 독립적으로 구현
      - 다른 스레드와 자료를 공유하지 않음
      - 각 스레드는 클라이언트 요청 하나를 처리
      - 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장
      - 결과적으로 스레드는 세상에 자신만 있는 듯이 돌아감
- 라이브러리를 이해하라
  - 스레드 환경에 안전한 컬렉션
    - 스레드에 사용해도 안전한 컬렉션 클래스 : java.util.concurrent (자바 5)
      - 자바 5를 사용한다면 ConcurrentHashMap을 사용해보자!
      - ReentrantLook : 한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)
      - Semaphore : 전형적인 세마포, 개수(count)가 있는 락
      - CountDownLatch : 지정한 수만큼 이벤트가 발생하고 나서야 대기 중이 스레드를 모두 해제하는 락
- 실행 모델을 이해하라
  - 기본 용어
    - 한정된 자원 (Bount Resource)
      - 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적
      - 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등
    - 상호 배제 (Mutual Exclusion)
      - 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킴
    - 기아 (Starvation) 
      - 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다림
      - 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠짐
    - 데드락 (Deadlock)
      - 여러 스레드가 서로가 끝나기를 기다림
      - 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못함
    - 라이브락 (Livelock)
      - 락을 거는 단계에서 각 스레드가 서로를 방해
      - 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못함
  - 다중 스레드 프로그래밍에서 사용하는 실행 모델
    - 생산자 - 소비자 (Producer-consumer)
      - 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원
      - 대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보냄
      - 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재
    - 읽기 - 쓰기 (Readers-Writers)
      - 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓임
      - 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어짐
      - 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요
- 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
  - 공유 객체 하나에는 메서드 하나만 사용
  - 공유 객체 하나에 여러 메서드가 필요한 상황에서 고려할 내용
    - 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고, 마지막 메서드를 호출할 때까지 잠금을 유지
    - 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현하고, 클라이언트는 이 메서드를 호출
    - 연결 서버 - 잠금을 수행하는 중간 단계를 생성하고, '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않음
- 동기화하는 부분을 작게 만들어라
  - 자바에서 synchronized 키워드를 사용하면 락을 설정
  - 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능
  - 락은 스레드를 지연시키고 부하를 가중시킴으로 여기저기서 synchronized 문을 남발하는 코드를 지양
  - 임계영역은 반드시 보호해야 하기에 코드를 짤 때는 임계영역 수를 최대한 줄여야 함
- 올바른 종료 코드는 구현하기 어려움
  - 데드락 : 스레드가 절대 오지 않을 시그널을 기다림
  - 깔끔하게 종료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현해야함
  - 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하려고 해야함
- 스레드 코드 테스트하기
  - 문제를 노출하는 테스트 케이스를 작성
  - 프로그램 설정과 시스템 설정과 부하를 바궈가며 자주 돌림
  - 테스트가 실패하면 원인을 추적
  - 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가지 말아야 함
  - 고려야하 하는 사항
    - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급
      - 시스템 실패를 '일회성'이라 치부하지 마라
    - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들어야 함
      - 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인
      - 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅 하지 마라.
      - 먼서 스레드 환경 밖에서 코드를 올바로 돌려라
    - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현
      - 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔봄
      - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려봄
      - 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려봄
      - 반복 테스트가 가능하도록 테스트 케이스를 작성
    - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성
      - 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구
      - 스레드 개수를 조율하기 쉽게 코드를 구현
      - 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려
      - 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민
    - 프로세서 수보다 많은 스레드를 돌려봐야함
      - 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌림
      - 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워짐
    - 다른 플랫폼에서 돌려봐야함
      - 다중 스레드 코드는 플랫폼에 따라 다르게 돌아감
      - 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 
    - 코드에 보조 코드(instrument)를 넣어 돌려서, 강제로 실패를 일으키게 해봐야함
      - 직접 구현하기
        - 코드에다 직접 wait(), sleep(), yield(), priority()함수를 추가
        - yield()를 삽입하면 코드가 실행되는 경로가 바뀌어서 코드가 실패할 가능성을 열어줌
        - 보조 코드를 삽일한 적정 위치를 직접 찾아야 함
        - 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어짐
        - 무작위적이라 오류가 드러나지 않을수도 있음
      - 자동화
        - 보조 코드를 자동으로 추가하려면 AOP, CGLIB, ASM 등과 같은 도구를 사용
        - 흔들기 기법을 사용해 오류를 찾아냄

## 점진적인 개선
- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다는 의미
- 테스트 주도 개발 (TDD)
  - 변형을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다
  - 변경 전후에 시스템이 똑같이 돌아간다는 사실을 확인하려면 언제든 실행이 가능한 자동화된 테스트 슈트가 필요

## JUnit 들여다보기

## SerialDate 리펙터링
- http://www.jfree.org/fcommon/index.php 에서 JCommon라이브러리를 제공
- JCommon 라이브러리를 뒤져보면 org.jfree.date라는 패키지가 있으며, 여기에 SerialDate라는 클래스가 존재
- SerialDate : 날짜를 표현하는 자바 클래스

## 냄새와 휴리스틱
- 주석
  - 부적적한 정보를 지양
    - 다른 시스템에 저장할 정보는 주석으로 적절하지 못함
    - 주석은 코드와 설계에 기술적인 설명을 부연하는 수단
  - 쓸모 없는 주석을 지양
    - 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없음
    - 쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋음
  - 중복된 주석을 지양
    - 코드만으로 충분한데 구구절절 설명하는 주석
  - 성의 없는 주석을 지양
    - 주석을 달 참이라면 시간을 들여 최대한 멋지게 작성
  - 주석 처리된 코드를 지양
    - 주석으로 처리된 코드를 발견하면 즉각 지워버려라!
- 환경
  - 여러 단계로 빌드해야 하는 것을 지양
    - 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 함
  - 여러 단계로 테스트 해야 하는 것을 지양
    - 모든 단위 테스트는 한 명령으로 돌려야 함
- 함수
  - 너무 많은 인수를 지양
    - 함수에서 인수 개수는 작을수록 좋음
    - 아예 없으면 가장 좋음
  - 출력 인수를 지양
    - 일반적으로 독자는 인수를 입력으로 간주
    - 함수에서 무너가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경
  - 플래그 인수를 지양
    - boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거
    - 플래그 인수는 혼란을 초래하므로 피해야 마땅함
  - 죽은 함수를 지양
    - 아무도 호출하지 않는 함수는 삭제함
    - 소스 코드 관리 시스템이 모두 기억하므로 걱정할 필요 없음
- 일반
  - 한 소스 파일에 여러 언어를 사용을 지양
  - 당연한 동작을 구현하지 않는 것을 지양
    - 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공
  - 경계를 올바로 처리하지 않는 것을 지양
    - 모든 경계 조건, 모든 구석진 곳, 모든 기벽, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킴
    - 스스로의 직관에 의존하지 말아야 함
    - 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성
  - 안전 절차를 무시하지 말아야 함
  - 중복을 지양
    - 코드에서 중복을 발견할 때마다 추상화할 기회로 간주
    - 중복된 코드를 하위 루틴이나 다른 클래스로 분리
    - 똑같은 코드가 여러 차례 나오는 중복은 간단한 함수로 교체
    - 똑같은 조건을 거듭 확인하는 중복은 다형성으로 대체
    - 알고리즘이 유사하나 코드가 서로 다른 중복 => TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거
  - 추상화 수준이 올바르지 못한것을 지양
    - 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념을 기초 클래스에 넣음
  - 기초 클래스가 파생 클래스에 의존하는 것을 지양
    - 기초클래스와 파생클래스는 나누는 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로 분리해 독립성을 보장
    - 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다
    - 기초 클래스는 파생 클래스를 아예 몰라야 함
  - 과도한 정보를 지양
    - 잘 정의된 모듈은 인터페이스가 아주 작음
    - 작은 인터페이스로도 많은 동작이 가능
  - 죽은 코드를 지양
    - 불가능한 조건을 확인하는 if문과 throw문이 없는 try문에서 catch 블록이 죽은 코드
    - 아무도 호출하지 않는 유틸리티 함수와 switch/case 문에서 불가능한 case 조건도 죽은 코드
  - 수직 분리를 지양
    - 변수와 함수는 사용되는 위치에 가깝게 정의
    - 지역변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치
  - 일관성 있게 작성
    - 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현
    - 표기법은 신중하기 선택하며, 일단 선택한 표기법은 신중하게 따름
  - 잡동사니를 지양
    - 아무도 사용하지 않는 변수, 아무도 호출하ㅣㅈ 않는 함수, 정보를 제공하지 못하는 주석 등을 제거
  - 인위적 결함을 지양
    - 서로 무관한 개념을 인위적으로 결합하지 않음
    - 인위적인 결함 : 직접적인 상호작용이 없는 두 모듈 사이에서 일어남
    - 함수, 상수, 변수를 선언할 때는 시간을 들여 올바른 위치를 고민
  - 기능 욕심을 지양
    - 메서드가 다른 객체의 참조자와 변경자를 사용해 그 객체 내용을 조작하는것을 지양
  - 선택자 인수를 지양
    - 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋음
  - 모호한 의도를 지양
  - 부적절한 static 함수를 지양
    - static으로 정의하면 안 되는 함수를 static으로 정의하면 안됨
    - 일반적으로 static 함수보다 인스턴스 함수가 더 좋음
    - 반드시 static 함수로 정의해야겠다면 재정의 할 가능성은 없는지 꼼꼼히 따져봐야 함
  - 서술적 변수 사용
    - 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간값으로 서술적인 변수 이름을 사용
    - 서술적인 변수 이름은 많이 써도 괜찮음
    ```
    Matcher match = headerPattern.matcher(line);
    if(match.find())
    {
     String key = match.group(1);
     String value = match.group(2);
     header.put(key.toLowerCase(), value);
     }
    ```
  - 알고리즘을 이해
    - 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인
    - 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고
  - 논리적 의존성은 물리적으로 드러내라
    - 의존하는 모듈이 상대모듈에 대해 뭔가를 가정(논리적의로 의존) 하면 안됨
    - 의존하는 모든 정보를 명시적으로 요청(물리적으로 의존) 하는 편이 좋음
  - If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
    - 선택 유형 하나에는 switch 문을 한번만 사용
    - 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch문을 대신
  - 표준 표기법을 사용
    - 구현 표준은 인스턴스 변수이름을 선언하는 위치, 클래스/메서드/변수 이름을 정하는 방법, 괄호를 넣는 위치 등을 명시해야함
    - 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요는 없어야 함
  - 매직 숫자는 명명된 상수로 교체
    - 일반적으로 코드에서 숫자를 사용하지 말고 명명된 상수 뒤로 숨기라는 의미
  - 정확하라
    - 갱신할 가능성이 희박하다고 잠금과 트랜잭션 관리를 건너뛰는 행동을 지양
    - 코드에서 뭔가를 결정할 때는 정확히 결정
    - 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 함
    - 호출하는 함수가 null을 반환할지도 모른다면 null을 반드시 점검
    - 조회 결과가 하나뿐이라 짐작한다면 하나인지 확실히 확인
    - 병행 특성으로 인해 동시에 갱신할 가능성이 있다면 적절한 잠금 매커니즘을 구현
    - 코드에서 모호성과 부정확은 의견차나 게으름의 결과
  - 관례보다 구조를 사용
    - 명명관례도 좋지만 구조 자체로 강제하면 더 좋음
    - enum 변수가 멋진 switch/case문보다 추상 메서드가 있는 기초 클래스가 더 좋음
  - 조건을 캡슐화
    - 조건의 의도를 분명히 밝히는 함수로 표현
    - if(shouldBeDeleted(timer)) => if( timer.hasExpired() && !timer.isRecurrent())
  - 부정 조건을 지양
    - 부정 조건은 긍정 조건보다 이해하기 어려움
    - if(buffer.shouldcompact()) => if(!buffer.shouldNotcompact())
  - 숨겨진 시간적인 결함을 지양
    - 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러냄
  - 일관성을 유지
    - 코드 구조를 잡을 때는 이유를 고민하고, 그 이유를 코드 구조로 명백히 표현
  - 경계 조건을 캡슐화
    - 경계 조건을 한 곳에서 별도로 처리
  - 함수는 추상화 수준을 한 단계만 내려가야함
    - 함수 내 모든 문장은 추상화 수준이 동일해야 함
    - 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 함
