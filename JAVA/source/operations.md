▷연산(operations) : 프로그램에서 데이터를 처리하여 결과를 산출하는 것

▷연산자(operator) : 연산에 사용되는 표시나 기호

▷피연산자(operand) : 연산되는 데이터

▷연산식(expressions) : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

▷연산식은 반드시 하나의 값을 산출한다.

▶연산자의 우선순위

  ▷증감(++,- -), 부호(+,-), 비트(~)(반전), 논리(!)(true,false)>산술(,/,%)>

     산술(+,-) >쉬프트(<<,>>,>>>)>비교(<,>,≤,≥,instanceof)>비교(==,!=)>

     논리(&)>논리(^) >논리(|)>논리(&&)>논리(||)>조건(?:)>

     대입(=,+=,-=,*=,/=,%=,&=,^=,|=,<<=,>>=,>>>=)

  ▷단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.

  ▷산술, 비교, 논리 ,대입 연산자 순으로 우선순위를 가진다.

  ▷단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다(→)

  ▷복잡한 연산식에는 괄호( )를 사용해서 우선순위를 정해준다.

▶단항 연산자 : 피연산자가 한 개인 연산자이다.

  ▷부호 연산자(+,-) : 양수와 음수를 표시한다. 산출 타입은 int 이다.

  ▷증감 연산자(++,- -) : 변수의 값을 1 증가(++) 시키거나 1 감소(- -)시키는 연산자를 말한다.

                                다른 연산자와 사용할 때 위치에 따라 결과가 다르게 나온다.

                                (증감연산자)(변수) = 우선 변수를 1 증가 또는 감소 시킨 후 다른 연산자와 계산한다.

                                (변수)(증감연산자) = 다른 연산자를 먼저 처리한 후 변수를 1 증가 또는 1 감소한다.

  ▷ 논리 부정 연산자(!) : boolean 타입에만 사용할 수 있다. true 를 false로, false를 true로 변경한다.

  ▷ 비트 반전 연산자(~) : 정수타입(byte, short, int, long)의 피연산자에만 사용되며,

                                  피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전한다.

                                  부호 비트인 최상위 비트를 포함해서 모든 비트가 반전되기 때문에,

                                  부호가 반대인 새로운 값이 산출된다.

                                  산출 타입은 int이다.

▶이항 연산자 : 피연산자가 두 개인 연산자이다.

  ▶산술연산자(+,-,*,/,%)

    ▷일반적인 사칙연산이다.

    ▷%연산자는 나눗셈을 수행하고, 몫이 아닌 나머지를 돌려주는 연산자이다.

    ▷피연산자들의 타입이 동일하지 않을 경우 long을 제외한 정수 타입 연산은 int 타입으로 산출되고,

       피연산자 중 하나라도 실수 타입이면 실수 타입으로 산출된다.

    ▶오버플로우 탐지 : 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 확인한다.

                              표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 엉뚱한 값을 얻을 수 있다.

      ○public class CheckOverFlowExample{

            public static void main(String [] args){

                try{

                     int result = safeAdd(2000000000,2000000000);

                     System.out.println(result);

                } catch(ArithmeticException e) {

                     System.out.println("오버플로우가 발생하여 정확하게 계산할 수 없음");

                }

            }

           public static int safeAdd(int left, int right) {

               if((right>0)){

                   if(left>(Integer.MAX_VALUE - right){

                        throw new ArithmeticException("오버플로우 발생");

                   }

               }else{

                   if(left>(Integer.MIN_VALUE - right){

                        throw new ArithmeticException("오버플로우 발생");

                   }

                }

            return left+right;

            }

         }

    ▷정확하게 계산해야 할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다.

       이진 포맷의 가수를 사용하는 부동소수점 타입은 0.1을 정확히 표현할 수 없어

       근사치로 처리하기 때문이다.

       정확한 계산이 필요하다면 정수 연산으로 변경해서 계산해야 한다.

    ▶NaN과 Infinity연산 

      ▷/ 또는 % 연산자를 사용할 때, 좌측 피연산자가 정수 타입인 경우에 나누는 수인

        우측 피연산자가 0을 사용할 시 컴파일은 정상적으로 되지만,

        실행 시 예외가 발생하여 예외 처리를 해야한다.

      ▷실수 타입인 0.0 또는 0.0f로 나누면 예외가 발생하지 않고, /연산의 결과는 무한대 값을 가지며,

         % 연산의 결과는 NaN(Not a Number)을 가진다.

         /와 % 연산의 결과가 무한대 또는 NaN이 나오면 다음 연산을 수행해서는 안 된다.

         Double.isInfinite()와 Double.isNaN() 메소드를 이용해서 확인한다. 

       ○if((Double.isInfinite(z) || Double.isNan(z)) {

             System.out.println("값 산출 불가");

          }else{ System.out.println(z+2);

          }

          //NaN 검사는 꼭 .isNaN을 사용해야 한다.

          if(Double.isNaN(val)) {

             System.out.println("NaN이 입력되어 처리할 수 없음");

             val = 0.0;

           }

  ▶문자열 연결 연산자(+)

      ▷문자열을 서로 결합하는 연산자이다.

      ▷피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어

         다른 피연산자를 문자열로 변환하고 서로 결합한다.

         문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행된다.

  ▶비교 연산자(<,<=,>=,==,!=)

      ▷대소 또는 동등을 비교해서 boolean 타입인 true/false를 산출한다.

      ▷0.1==0.1f(false) 인 이유는 이진 포맷의 가수를 사용하는 모든 부동소수점 타입은

         0.1을 정확히 표현할 수가 없어 근사값으로 표현되기 때문이다.

         해결책은 float 타입으로 강제 타입 변환한 후에 비교 연산을 하든지, 정수로 변환해서 비교하면 된다.

      ▷String 객체의 문자열만을 비교하고 싶다면 == 연산자 대신에 equals()메소드를 사용해야 한다.     

  ▶논리 연산자(&&,||,|,^,!)

      ▷AND(&&) : 피연산자 모두가 true 일 경우에만 연산 결과는 true

      ▷OR(||) : 피연산자 중 하나만 true이면 연산 결과는 true

      ▷XOR(^) : 피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true

      ▷NOT(!) : 피연산자의 논리값을 바꿈

  ▶비트 연산자(&,|,^,~,<<,>>,>>>)

      ▷0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.

      ▷비트 연산자는 피연산자를 int 타입으로 자동 타입 변환한 후 연산을 수행한다.

      ▶비트 논리 연산자(&, |, ^, ~)

        ▷&,|,^ 연산자는 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고,

           피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용된다.

        ▷AND(논리곱 &) : 두 비트 모두 1일 경우에만 연산 결과가 1

        ▷OR(논리합 |) : 두 비트 중 하나만 1 이면 연산 결과는 1

        ▷XOR(배타적 논리합 ^) : 두 비트 중 하나는 1 이고 다른 하나가 0일 경우 연산 결과는 1

        ▷NOT(~) : 보수 

      ▶비트 이동 연산자(<<, >>, >>>)

        ▷정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

        ▷a << b : 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)

        ▷a >> b : 정수 a의 각 비트를 b만큼 오른쪽으로 이동

           (빈자리는 정수 a의 최상위 부호 비트(MSB)와 같은 값으로 채워진다.)

        ▷a >>>b : 정수 a의 각 비트를 b만큼 오른쪽으로 이동 (빈자리는 0으로 채워진다.)

  ▶대입 연산자(=,+=,-=,*=,/=,%=,&=,^=,|=,<<=,>>=,>>>=)

    ▷단순 대입 연산자 : 단순히 오른쪽 피연산자의 값을 변수에 저장

    ▷복합 대입 연산자 : 정해진 연산을 수행한 후 결과를 변수에 저장

    ▷대입 연산자는 모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있기 때문에

       제일 마지막에 수행된다.

▶삼항 연산자

  ▷? 앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다.

  ▷조건식(피연산자1) ? 값 또는 연산식(피연산자2) : 값 또는 연산식(피연산자3)

  ▷조건식을 연산하여 true가 나오면 삼항 연산자의 결과는 피연산자2가 된다.

  ▷조건식을 연산하여 false가 나오면 삼항 연산자의 결과는 피연산자3가 된다.